## Homework Assignment 4
### HDR imaging and Tonemapping

20233613 Hwi Jeong Lee

### 1. HDR IMAGING (50 POINTS)

Use `dcraw` to convert the RAW .NEF images into linear 16-bit .TIFF images. For this, I direct `dcraw` to do white balancing using the camera's profile for white balancing, do demosaicing using high-quality interpolation, and use sRGB as the output color space. Below is the flags I use.

```
-w - Enables automatic white balancing using the camera's profile.
-q 3 - Sets the demosaicing interpolation method to high-quality.
-4 - Outputs 16-bit linear TIFF images.
-T - Generates a linear image
-o 1 - Sets the output color space to sRGB.

dcraw -w -q 3 -4 -T -o 1 ./exposure_stack/exposure*.nef
```

#### LINEARIZE RENDERED IMAGES (25 POINTS)

Unlike the RAW images, which are linear, the rendered images are non-linear. So before merging them into an HDR image, I first need to perform radiometric calibration in order to undo this non-linearity. For this, I should revocer function g by solving the least squares optimization problem. The process is shown in gsolve.m code and two examples plot of the function g is provided below. (I use two weighting scheme e.g., uniform, tent)

```matlab
function [ g ] = gsolve(Z,B,l,w)
	n = 256;
	A = sparse(size(Z,1)*size(Z,2)+n+1, n+size(Z,1));
	b = zeros(size(A,1),1);

	k = 1;
	for i=1:size(Z,1)
	for j=1:size(Z,2)
	    wij = w(Z(i,j)+1);
	    A(k,Z(i,j)+1) = wij;
	    A(k,n+i) = -wij;
	    b(k,1) = wij * B(j);
	    k=k+1;
	end
	end

	A(k,129) = 1;
	k=k+1;

	for i=1:n-2
	A(k,i)=l*w(i+1);
	A(k,i+1)=-2*l*w(i+1);
	A(k,i+2)=l*w(i+1);
	k=k+1;
	end

	x = A\b;
	g = x(1:n);
end

```

####	Result

#### ![1](https://github.com/HwiJeong-Lee/cp-project/blob/main/results/g%20plot/g%20plot_rendered_logarithmic_tent.png)

![2](https://github.com/HwiJeong-Lee/cp-project/blob/main/results/g%20plot/g%20plot_raw_linear_uniform.png)



#### MERGE EXPOSURE STACK INTO HDR IMAGE (15 POINTS)

Now that I have two sets of (approximately) linear images, coming from the RAW and rendered files, I merge each one of them into an HDR image. I create total of 8 HDR images: 2 sets of images (RAW and rendered) x 2 merging schemes (linear and logarithmic) x 2 weighting schemes (uniform, tent). I set the clipping values `Zmin` and `Zmax` as 0.01 and 0.95, respectively. The result of the HDR images are stored in the directory (./results/hdr images). 

```matlab
function [ imgHDR ] = hdr_merging( imgs, g, exposures, weight, IMAGE_TYPE, MERGING_SCHEME )

    img_num = size(imgs, 2);
    [height, width, channel] = size(imgs{1});

    imgHDR = zeros(height, width, channel);

    for c = 1:channel
        for h = 1:height
            for w = 1:width
                num = 0;
                denom = 0;
                for k = 1:img_num
                    I_cur = imgs{k}(h, w, c);
                    w_cur = weight(I_cur + 1);
                    ln_t_cur = exposures(k);                    
                    
                    if strcmp(IMAGE_TYPE, 'rendered')
                        % convert non-linear image to linear
                        I_cur = exp(g(I_cur + 1));
                    elseif strcmp(IMAGE_TYPE, 'raw')
                        I_cur = I_cur / 255.;
                    end

                    denom = denom + w_cur;
                    
                    if strcmp(MERGING_SCHEME, 'linear')
                        num = num + w_cur * I_cur / exp(ln_t_cur);
                    elseif strcmp(MERGING_SCHEME, 'logarithmic')
                        num = num + w_cur * (log(I_cur) - ln_t_cur);
                    end                                     
                end
                imgHDR(h, w, c) = num / denom;                
            end
        end
    end
    
    if strcmp(MERGING_SCHEME, 'logarithmic')
        imgHDR = exp(imgHDR);
    end                                     

    % remove NAN or INF
    idx = find(isnan(imgHDR) | isinf(imgHDR));
    imgHDR(idx) = 0;    
end
```



#### EVALUATION (10 POINTS)

To evaluate the results of an HDR creation process , I chieck its linearity. The process is as follows: (1) convert the HDR image to the XYZ color space, and extract the Y channel (luminance). (2) using the cropped squares you created earlier, compute the average luminance for each of the six neutral patches. (3) perform linear regression to the logarithms of these six average luminances. (4) compute the least-squares error between the actual average 
luminance values and the linear fit you created. The results of the regression plot and responding **R-squared** and **LSE** values are in the repository (./results/regression plot). Since the case (raw / tent / linear) shows the best R-squared value, thus I use this HDR image as the following tonemapping experiments.

```matlab
% EVALUATION (10 POINTS)
if DO_EVALUATION
    hdr_img = hdrread(hdr_path);
    
    % Display the HDR image
    figure;
    imshow(imgHDR);
    title('Select neutral patches');

    % Define the number of neutral patches
    num_patches = 6;
    
    % Initialize patch_coordinates array
    patch_coordinates = zeros(num_patches, 4);

    % Get coordinates for each neutral patch
    for i = 1:num_patches
        % Get user input for patch coordinates
        fprintf('Select top-left and bottom-right corners of neutral patch %d\n', i);
        fprintf('Click on the top-left corner of the patch.\n');
        [x1, y1] = ginput(1);
        fprintf('Click on the bottom-right corner of the patch.\n');
        [x2, y2] = ginput(1);
        
        % Round the coordinates to integers
        x1 = round(x1);
        y1 = round(y1);
        x2 = round(x2);
        y2 = round(y2);
        
        % Store the coordinates in the patch_coordinates array
        patch_coordinates(i, :) = [x1, y1, x2-x1, y2-y1];
        
        % Draw a rectangle to visualize the selected patch
        hold on;
        rectangle('Position', [x1, y1, x2-x1, y2-y1], 'EdgeColor', 'r', 'LineWidth', 2);
        hold off;
    end

    % Display the final patch coordinates
    disp('Neutral patch coordinates:');
    disp(patch_coordinates);

    img_XYZ = rgb2xyz(hdr_img, 'Colorspace', 'linear-rgb');
    
    L = img_XYZ(:,:,2);

    L_x = zeros(6, 1);
    L_y = zeros(6, 1);
    
    % coordinates of the cropped squares
    top_left = [375 62; 376 78; 376 93; 377 110; 377 125; 378 141;];
    bottome_right = [387 73; 388 89; 388 105; 388 122; 389 138; 390 153;];

    for i = 1:6       
        L_y(i) = mean(mean(L(top_left(i,2):bottome_right(i,2), top_left(i,1):bottome_right(i,1))));
        L_x(i) = i;
    end
    
    % Linear regression using fitlm
    lr = fitlm(L_x, L_y);
    % Compute the predicted values
    predicted_y = predict(lr, L_x);
    % Compute the least-squares error
    LSE = sum((L_y - predicted_y).^2);
end
```

####	Result

![3](https://github.com/HwiJeong-Lee/cp-project/blob/main/results/regression%20plot/regression%20plot_raw_linear_tent.png)



### 2. TONEMAPPING (50 POINTS)



#### PHOTOGRAPHIC TONEMAPPING (20 POINTS)

In this step, I implement the tonemapping operator proposed by Reinhard et al. For displaying HDR images and apply it to my RGB images in two ways: (1) RGB color channel separately and (2) only the luminance channel Y. The parameters used is as follows. As shown in below, applying the photographic tonemapping into RGB color channel separately looks more natural.

```matlab
if DO_PHOTOGRAPHIC_TONEMAPPING
    % parameters of phtographic tonemapping
    K_rgb = 0.7;
    B_rgb = 0.9;
    K_xyY = 0.15;
    B_xyY = 0.95;
    imgHDR = double(hdrread(hdr_path));

    imgTMP_rgb = photographic_tonemapping(imgHDR, K_rgb, B_rgb, 'rgb');
    imgTMP_xyY = photographic_tonemapping(imgHDR, K_xyY, B_xyY, 'xyY');
```

```matlab
function [ imgTMP ] = photographic_tonemapping( imgHDR, K, B, colorSpace )
    % parameters
    N = size(imgHDR, 1) * size(imgHDR, 2);
    e = 1e-6;
    [height, width, channel] = size(imgHDR);
	
	% rgb colorspace
    if strcmp(colorSpace, 'rgb')
        imgTMP = zeros(height, width, channel);
        
        for c = 1:channel
            I_HDR = imgHDR(:,:,c);
            I_m_HDR = exp(mean(mean(log(I_HDR + e))));

            I_HDR_ = (K / I_m_HDR) * I_HDR;
            I_white_ = B * max(max(I_HDR_));

            I_HDR_tonemapping = I_HDR_ .* (1 + I_HDR_ / (I_white_ * I_white_)) ./ (1 + I_HDR_);

            imgTMP(:,:,c) = I_HDR_tonemapping;
        end
        
	% xyY colorspace
		...
```

####	Result

![4](https://github.com/gaviotas/cp_project/blob/main/A4/figures/4.png?raw=true)

#### TONEMAPPING USING BILATERAL FILTERING (30 POINTS)

Additionally, I implement the tonemapping using bilateral filtering. The parameters used and the results are shown below. Compared to the results without bilateral filtering, bilateral filtering emphasizes the edges of the image. I prefer tonemapping using bilateral filtering in RGB channel separately the most in terms of getting the edges of the image more accurate.

```matlab
if DO_TONEMAPPING_USING_BILATERAL_FILTERING
    % parameters of tonmapping using bilateral filtering
    kernel_size = 5;
    S_rgb = 0.20;
    sigma_d = 2;
    sigma_r = 0.2;
    imgHDR = double(hdrread(hdr_path));

    imgTMP_rgb = tonemapping_using_bilateral_filtering(imgHDR, kernel_size, S_rgb, sigma_d, sigma_r, 'rgb');
    imgTMP_xyY = tonemapping_using_bilateral_filtering(imgHDR, kernel_size, S_rgb, sigma_d, sigma_r, 'xyY');
```

```matlab
function [ imgTM ] = tonemapping_using_bilateral_filtering( imgHDR, kernel_size, S, sigma1, sigma2, colorSpace )
    % parameters
    N = size(imgHDR, 1) * size(imgHDR, 2);
    e = 1e-6;
    [height, width, channel] = size(imgHDR);

    % rgb colorspace
    if strcmp(colorSpace, 'rgb')
        imgTM = zeros(height, width, channel);
        
        for c = 1:channel
            L = log(imgHDR(:,:,c) + e);
            L_min = min(min(L));
            L_max = max(max(L));
            
            L_temp = (L - L_min) / (L_max - L_min);
            % bilateral filtering
            B_temp = bfilter2(L_temp, kernel_size, [sigma1 sigma2]);
            B = B_temp * (L_max - L_min) + L_min;
            D = L - B;
            B_ = S * (B - max(max(B)));
            I_TM = exp(B_ + D);
            
            imgTM(:,:,c) = I_TM;
        end
        
	% xyY colorspace
		...
```

####	Result

![5](https://github.com/gaviotas/cp_project/blob/main/A4/figures/5.png?raw=true)
